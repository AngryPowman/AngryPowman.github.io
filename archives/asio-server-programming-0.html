<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><title> ASIO服务器编程系列0：概述与设计 · 愤怒的泡面</title><meta name="description" content="ASIO服务器编程系列0：概述与设计 - AngryPowman"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://powman.org/atom.xml" title="愤怒的泡面"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">愤怒的泡面</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/feedback" target="_self" class="li component-nav-item"><p>留言板</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于我</p></a><ul class="shortcut-icons"><a href="https://github.com/AngryPowman" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="https://www.zhihu.com/people/AngryPowman" target="_blank"><img src="/images/zhihu.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">ASIO服务器编程系列0：概述与设计</h1><div class="post-info">Jun 16, 2013</div><div class="post-content"><p>BOOST::ASIO为我们提供了两种I/O机制，分别是同步和异步。它可在多平台上移植，在不同系统上采用了不同的实现。ASIO为我们封装了一系列的socket api，同时为我们提供了一套相当完善的服务器编程体系，部分概念（关键词）如：io队列、基于回调的异步通知、定时器、自定义的多线程机制。<br><a id="more"></a><br>假设大家已经安装好了boost，并有一些C++基础，针对TCP服务器编程，我们有如下需求：<br>1.一个可用于接受新连接的类<br>2.提供基本的send/recv io操作<br>3.解决多线程下的资源竞争问题<br>4.管理连接的生命周期<br>5.为不同的网络事件提供回调方法</p>
<p>针对以上需求，先来设计一个简单的框架。我们分为TCPServer, Acceptor, Connection三个主要的类。它们的功能分别如下：<br>TCPServer : 对用户可见，用于启动服务，终止服务。一个服务需要一个TCPServer对象。<br>Acceptor : 对用户不可见。用于监听并接受新的客户端连接。有新连接到来之后通知TCPServer，由TCPServer告知用户。<br>Connection : 对用户可见。封装了对客户端连接的一个实体，每个Connection对象表示与客户端的一个连接。由智能指针管理生命周期。</p>
<p>时序图如下：<br><a href="/images/wp-migrate-res/2013/06/uml_connect_sequence1.jpg"><img src="/images/wp-migrate-res/2013/06/uml_connect_sequence1.jpg" alt="uml_connect_sequence"></a><br>如上图所示，客户端先发起一个连接，Acceptor会接受该连接，然后通过回调告知TCPServer，再由TCPServer通知用户（这里指TCPServer的上层使用者）有一个新的客户端接入了。那么，Acceptor应该通过什么方式去告知TCPServer，而用户又通过什么样的方式去获得这些通知呢？我们来画一个服务启动时的时序图：<br><a href="/images/wp-migrate-res/2013/06/uml_start_server_sequence.jpg"><img src="/images/wp-migrate-res/2013/06/uml_start_server_sequence.jpg" alt="uml_start_server_sequence"></a></p>
<p>首先，User角色代表的也就是我们说的应用层用户，它先向TCPServer注册一些事件，而这些注册的事件，就是我们需要回调的方法。然后在启动Acceptor的时候，同时向Acceptor注册它所关心的事件，当Acceptor接受到新的连接时，它也会同时向新创建的Connection对象注册它所关心的事件。</p>
<p>这里所说的“注册事件”实质上是指设置一个函数指针。前段时间曾经在muduo的相关文章中看到陈硕提出了使用bind/functional方式来实现服务器网络事件的回调工作，我们不再需要和过去我们熟知的那种方式去继承某个类然后实现其接口，这种做法无疑会增加代码编写的灵活性，但他的文中同时提出的“继承是个坑”，我感觉这是一种比较情绪化的说法，不应该去拘泥哪种做法，个人建议根据具体场景去设计即可。</p>
<p>服务器的设计如上所述，下面将从ASIO的io_service说起，一步步去完善一个小型的服务端程序，并会逐一去解决需求中尚未实现的几条。</p>
<p><img src="http://powman.org/wp-includes/js/tinymce/plugins/wordpress/img/trans.gif" alt="" title="更多..."><!--more--><br>未完待续…</p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'angrypowman';
var disqus_identifier = 'archives/asio-server-programming-0.html';
var disqus_title = 'ASIO服务器编程系列0：概述与设计';
var disqus_url = 'https://powman.org/archives/asio-server-programming-0.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//angrypowman.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/archives/io-service-detail-1.html" class="prev">PREV</a><a href="/archives/fleible-array.html" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="https://powman.org">AngryPowman</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-93668618-1",'auto');ga('send','pageview');</script></body></html>