<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><title> ASIO服务器编程系列1：io_service的工作机制与跨平台策略 · 愤怒的泡面</title><meta name="description" content="ASIO服务器编程系列1：io_service的工作机制与跨平台策略 - AngryPowman"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://powman.org/atom.xml" title="愤怒的泡面"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">愤怒的泡面</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/feedback" target="_self" class="li component-nav-item"><p>留言板</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于我</p></a><ul class="shortcut-icons"><a href="https://github.com/AngryPowman" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="https://www.zhihu.com/people/AngryPowman" target="_blank"><img src="/images/zhihu.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">ASIO服务器编程系列1：io_service的工作机制与跨平台策略</h1><div class="post-info">Jun 30, 2013</div><div class="post-content"><blockquote>
<p>以当前最新版本的boost为例(<a href="http://www.boost.org/doc/libs/1_53_0/" target="_blank" rel="external">1.53.0</a>，之后的代码也是以1.53.0为准)。</p>
<p>ASIO Examples：<a href="http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/examples.html" target="_blank" rel="external">http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/examples.html</a><br>io_service在ASIO中有着举足轻重的地位置如果对io_service的实现不感兴趣可以选择性无视这篇文章。在开始说io_service之前，先介绍一下ASIO给我们提供的可用于TCP服务器开发的组件。</p>
</blockquote>
<a id="more"></a>
<table border="0" align="left"><br><tbody><br><tr><br><td><strong>boost::asio::ip::tcp::acceptor</strong></td><br><td> 用于监听与接受连接的类。</td><br></tr><br><tr><br><td><strong>boost::asio::ip::tcp::socket</strong></td><br><td> 套接字，提供同步/异步IO方法，一个socket对象面向一个客户端连接。</td><br></tr><br><tr><br><td><strong>boost::asio::deadline_timer</strong></td><br><td> 计时器，提供同步/异步计时功能并在计时结束之后回调到一个函数。</td><br></tr><br></tbody><br></table>

<h2 id="io-service的工作方式"><a href="#io-service的工作方式" class="headerlink" title="io_service的工作方式"></a>io_service的工作方式</h2><p>把io_service想象为一个Worker Pool，也可以把它当作一个IO队列，他是一个联系用户和ASIO核心实现的类。如果你看过ASIO的例子或者用过ASIO，在构造上面表格中的对象时，往往需要给它们传递一个io_service对象，因为io_service担任的是一个Worker Pool的作用，这些组件的任何IO操作都会通过io_service.post()方法去投递一个任务。</p>
<p>为了更直观地看到io_service的作用，来一段异步定时器(<a href="http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/reference/deadline_timer.html" title="deadline_timer" target="_blank" rel="external">deadline_timer</a>)工作的代码：</p>
<p>[cpp]</p>
<p>#include &lt;boost/bind.hpp&gt;  //for std::bind()</p>
<p>#include &lt;boost/asio.hpp&gt;</p>
<p>int main()<br>{<br>    void on_expired();</p>
<pre><code>boost::asio::io_service io_service;
boost::asio::deadline_timer timer(io_service);
timer.expires_from_now(boost::posix_time::milliseconds(3000));
timer.async_wait(boost::bind(on_expired, boost::asio::placeholders::error));
io_service.run();

return 0;
</code></pre><p>}</p>
<p>void on_expired(const boost::system::error_code&amp; error)<br>{<br>    if (!error)<br>    {<br>        std::cout &lt;&lt; &quot;timer expired.&quot; &lt;&lt; std::endl;<br>    }<br>}<br>[/cpp]</p>
<p>上面代码演示了一个异步定时器的工作流程：<br>1.定义一个io_service对象。<br>2.定义一个deadline_timer对象，并把io_service对象作为唯一参数传递给它。<br>3.使用expires_from_now()方法设置一个以当前时间为起始点的超时时间。<br>4.调用deadline_timer的async_wait()方法使定时器进入等待。<br>5.调用io_service的run()方法。</p>
<p>第4步调用async_wait()方法之后，deadline_timer的内部就做了一些和io_service打交道的事，它实则是向io_service提交了一个异步任务，io_service会把它放到队列里。第5步我们调用run()方法时，io_service就开始了它的工作，并把队列中的任务进行处理。</p>
<p>io_service用例图：<br><a href="/images/wp-migrate-res/2013/06/uml_io_service.jpg">
</a><a href="/images/wp-migrate-res/2013/06/uml_io_service.jpg"><img src="/images/wp-migrate-res/2013/06/uml_io_service.jpg" alt="uml_io_service"></a></p>
<p>这个用例图展示了io_service的工作方式：<br>1.用户的应用程序提交一个操作。<br>2.操作转发给io_service，告诉它我有一个异步操作可能要执行，此时io_service便会把该操作放入一个队列里。<br>3.调用run()方法启动io_service。<br>4.io_service启动后，会把队列中的操作提交给操作系统，相当于一个联系了用户和操作系统的媒介。<br>5.操作系统把执行结果反馈给io_service，io_service会根据结果构造一个boost::system::error_code对象并回调给用户，通过该对象可获知所投递操作的执行结果。</p>
<p>流程很简单，从我们的应用程序逐层向下，完成之后再逐层向上反馈。但是，我们看到的其实只是冰山一角。ASIO是一个网络库，除了给我们提供了定时器这类开发组件之外，更重要的是它的网络通信功能。ASIO提供的网络通信功能，不仅封装了操作系统提供的socket api，同时也用自己的思想把不同平台的网络通信模型封装了起来。下面我们来深入io_service，揭开其面纱。</p>
<h2 id="io-service的跨平台策略"><a href="#io-service的跨平台策略" class="headerlink" title="io_service的跨平台策略"></a>io_service的跨平台策略</h2><p>考虑到在多平台下的实现细节，io_service可谓是做了不少功夫。要根据不同平台提供的api去设计一个统一的框架提供给用户，而且用户不必关心其实现细节，除了工程庞大之外，也必须要有一个良好的框架。我们从io_service的源码入手，探讨它如何去适应不同平台的实现。（推荐用Source Insight, Sublime Text 2或VC编辑器阅读源码）。</p>
<p>由io_service.run()开始，先转到run()的定义：</p>
<p>[cpp]std::size<em>t s = impl</em>.run(ec);[/cpp]</p>
<p>该方法实则上是调用了impl_对象的run()方法，看起来是io<em>service在impl</em>的基础上封装了一层，impl_是io<em>service的成员，不难看出，impl</em>担任了一个实现功能细节的角色。在io<em>service类的声明中，找到impl</em>的声明：</p>
<p>[cpp]<br>// The implementation.<br>impl<em>type&amp; impl</em>;<br>[/cpp]</p>
<p>然后是impl_type类型的定义：</p>
<p>[cpp]<br>typedef detail::io_service_impl impl_type;<br>[/cpp]</p>
<p>原来impl_type的原本类型是detail::io_service_impl，实质上它是由宏来决定其最终类型。转到定义可以发现：</p>
<p>[cpp]</p>
<p>#if defined(BOOST_ASIO_HAS_IOCP)<br>namespace detail { typedef win_iocp_io_service io_service_impl; }</p>
<p>#else<br>namespace detail { typedef task_io_service io_service_impl; }</p>
<p>#endif<br>[/cpp]</p>
<p>上面代码很清晰可以看到，如果定义了BOOST_ASIO_HAS_IOCP这个宏，那么io_service_impl的类型就是<strong>win_iocp_io_service</strong>，否则就是<strong>task_io_service</strong>. 如此说来，io_service_impl这个类型完全是由BOOST_ASIO_HAS_IOCP宏来决定的。跟踪一下这个宏，看它如何定义：</p>
<p>[cpp]<br>// Windows: IO Completion Ports.</p>
<p>#if defined(BOOST_WINDOWS) || defined(<strong>CYGWIN</strong>)</p>
<h1 id="if-defined-WIN32-WINNT-amp-amp-WIN32-WINNT-gt-0x0400"><a href="#if-defined-WIN32-WINNT-amp-amp-WIN32-WINNT-gt-0x0400" class="headerlink" title="if defined(_WIN32_WINNT) &amp;&amp; (_WIN32_WINNT &gt;= 0x0400)"></a>if defined(_WIN32_WINNT) &amp;&amp; (_WIN32_WINNT &gt;= 0x0400)</h1><h1 id="if-defined-UNDER-CE"><a href="#if-defined-UNDER-CE" class="headerlink" title="if !defined(UNDER_CE)"></a>if !defined(UNDER_CE)</h1><h1 id="if-defined-BOOST-ASIO-DISABLE-IOCP"><a href="#if-defined-BOOST-ASIO-DISABLE-IOCP" class="headerlink" title="if !defined(BOOST_ASIO_DISABLE_IOCP)"></a>if !defined(BOOST_ASIO_DISABLE_IOCP)</h1><h1 id="define-BOOST-ASIO-HAS-IOCP-1"><a href="#define-BOOST-ASIO-HAS-IOCP-1" class="headerlink" title="define BOOST_ASIO_HAS_IOCP 1"></a>define BOOST_ASIO_HAS_IOCP 1</h1><h1 id="endif-defined-BOOST-ASIO-DISABLE-IOCP"><a href="#endif-defined-BOOST-ASIO-DISABLE-IOCP" class="headerlink" title="endif // !defined(BOOST_ASIO_DISABLE_IOCP)"></a>endif // !defined(BOOST_ASIO_DISABLE_IOCP)</h1><h1 id="endif-defined-UNDER-CE"><a href="#endif-defined-UNDER-CE" class="headerlink" title="endif // !defined(UNDER_CE)"></a>endif // !defined(UNDER_CE)</h1><h1 id="endif-defined-WIN32-WINNT-amp-amp-WIN32-WINNT-gt-0x0400"><a href="#endif-defined-WIN32-WINNT-amp-amp-WIN32-WINNT-gt-0x0400" class="headerlink" title="endif // defined(_WIN32_WINNT) &amp;&amp; (_WIN32_WINNT &gt;= 0x0400)"></a>endif // defined(_WIN32_WINNT) &amp;&amp; (_WIN32_WINNT &gt;= 0x0400)</h1><p>#endif // defined(BOOST_WINDOWS) || defined(<strong>CYGWIN</strong>)</p>
<p>// Linux: epoll, eventfd and timerfd.</p>
<p>#if defined(<strong>linux</strong>)</p>
<h1 id="include-lt-linux-version-h-gt"><a href="#include-lt-linux-version-h-gt" class="headerlink" title="include &lt;linux/version.h&gt;"></a>include &lt;linux/version.h&gt;</h1><h1 id="if-defined-BOOST-ASIO-DISABLE-EPOLL"><a href="#if-defined-BOOST-ASIO-DISABLE-EPOLL" class="headerlink" title="if !defined(BOOST_ASIO_DISABLE_EPOLL)"></a>if !defined(BOOST_ASIO_DISABLE_EPOLL)</h1><h1 id="if-LINUX-VERSION-CODE-gt-KERNEL-VERSION-2-5-45"><a href="#if-LINUX-VERSION-CODE-gt-KERNEL-VERSION-2-5-45" class="headerlink" title="if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,45)"></a>if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,45)</h1><h1 id="define-BOOST-ASIO-HAS-EPOLL-1"><a href="#define-BOOST-ASIO-HAS-EPOLL-1" class="headerlink" title="define BOOST_ASIO_HAS_EPOLL 1"></a>define BOOST_ASIO_HAS_EPOLL 1</h1><h1 id="endif-LINUX-VERSION-CODE-gt-KERNEL-VERSION-2-5-45"><a href="#endif-LINUX-VERSION-CODE-gt-KERNEL-VERSION-2-5-45" class="headerlink" title="endif // LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,45)"></a>endif // LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,45)</h1><h1 id="endif-defined-BOOST-ASIO-DISABLE-EVENTFD"><a href="#endif-defined-BOOST-ASIO-DISABLE-EVENTFD" class="headerlink" title="endif // !defined(BOOST_ASIO_DISABLE_EVENTFD)"></a>endif // !defined(BOOST_ASIO_DISABLE_EVENTFD)</h1><h1 id="if-defined-BOOST-ASIO-DISABLE-EVENTFD"><a href="#if-defined-BOOST-ASIO-DISABLE-EVENTFD" class="headerlink" title="if !defined(BOOST_ASIO_DISABLE_EVENTFD)"></a>if !defined(BOOST_ASIO_DISABLE_EVENTFD)</h1><h1 id="if-LINUX-VERSION-CODE-gt-KERNEL-VERSION-2-6-22"><a href="#if-LINUX-VERSION-CODE-gt-KERNEL-VERSION-2-6-22" class="headerlink" title="if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,22)"></a>if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,22)</h1><h1 id="define-BOOST-ASIO-HAS-EVENTFD-1"><a href="#define-BOOST-ASIO-HAS-EVENTFD-1" class="headerlink" title="define BOOST_ASIO_HAS_EVENTFD 1"></a>define BOOST_ASIO_HAS_EVENTFD 1</h1><h1 id="endif-LINUX-VERSION-CODE-gt-KERNEL-VERSION-2-6-22"><a href="#endif-LINUX-VERSION-CODE-gt-KERNEL-VERSION-2-6-22" class="headerlink" title="endif // LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,22)"></a>endif // LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,22)</h1><h1 id="endif-defined-BOOST-ASIO-DISABLE-EVENTFD-1"><a href="#endif-defined-BOOST-ASIO-DISABLE-EVENTFD-1" class="headerlink" title="endif // !defined(BOOST_ASIO_DISABLE_EVENTFD)"></a>endif // !defined(BOOST_ASIO_DISABLE_EVENTFD)</h1><h1 id="if-defined-BOOST-ASIO-HAS-EPOLL"><a href="#if-defined-BOOST-ASIO-HAS-EPOLL" class="headerlink" title="if defined(BOOST_ASIO_HAS_EPOLL)"></a>if defined(BOOST_ASIO_HAS_EPOLL)</h1><h1 id="if-GLIBC-gt-2-GLIBC-2-amp-amp-GLIBC-MINOR-gt-8"><a href="#if-GLIBC-gt-2-GLIBC-2-amp-amp-GLIBC-MINOR-gt-8" class="headerlink" title="if (GLIBC &gt; 2) || (GLIBC == 2 &amp;&amp; GLIBC_MINOR &gt;= 8)"></a>if (<strong>GLIBC</strong> &gt; 2) || (<strong>GLIBC</strong> == 2 &amp;&amp; <strong>GLIBC_MINOR</strong> &gt;= 8)</h1><h1 id="define-BOOST-ASIO-HAS-TIMERFD-1"><a href="#define-BOOST-ASIO-HAS-TIMERFD-1" class="headerlink" title="define BOOST_ASIO_HAS_TIMERFD 1"></a>define BOOST_ASIO_HAS_TIMERFD 1</h1><h1 id="endif-GLIBC-gt-2-GLIBC-2-amp-amp-GLIBC-MINOR-gt-8"><a href="#endif-GLIBC-gt-2-GLIBC-2-amp-amp-GLIBC-MINOR-gt-8" class="headerlink" title="endif // (GLIBC &gt; 2) || (GLIBC == 2 &amp;&amp; GLIBC_MINOR &gt;= 8)"></a>endif // (<strong>GLIBC</strong> &gt; 2) || (<strong>GLIBC</strong> == 2 &amp;&amp; <strong>GLIBC_MINOR</strong> &gt;= 8)</h1><h1 id="endif-defined-BOOST-ASIO-HAS-EPOLL"><a href="#endif-defined-BOOST-ASIO-HAS-EPOLL" class="headerlink" title="endif // defined(BOOST_ASIO_HAS_EPOLL)"></a>endif // defined(BOOST_ASIO_HAS_EPOLL)</h1><p>#endif // defined(<strong>linux</strong>)<br>[/cpp]</p>
<p>如果在Windows或者CYGWIN环境并且IOCP未被禁用的情况下，那么ASIO的网络模型就会被定义为IOCP；而在linux下，则有epoll, eventfd, timerfd三种情况，但结合io_service_impl的定义，可以发现除了BOOST_ASIO_HAS_IOCP在打开时io_service_impl被定义为win_iocp_io_service之外，其它情况都是task_io_service. <strong>因此可以把ASIO归纳为只有两种实现，分别是win_iocp_io_service和task_io_service</strong>. 而在io<em>service中impl</em>成员的最终类型，也只有这两种。无论采用了哪种模型，io<em>service暴露的方法都一样，他们的具体实现都必须转给impl</em>去做。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a href="/images/wp-migrate-res/2013/06/service_level_table.jpg"><img src="/images/wp-migrate-res/2013/06/service_level_table.jpg" alt="service_level_table"></a></h2><!--more-->
<p>这一章简要说了一下io_service的组成和工作机制，接着将介绍io_service的Proactor框架实现和io_service的service管理。因为这一章的内容和接下来要说的内容关联不算太大，而且说到Proactor实现部分比较长。其实下一章内容写的差不多了，不过还要写几天再发，先发这篇短的。</p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'angrypowman';
var disqus_identifier = 'archives/io-service-detail-1.html';
var disqus_title = 'ASIO服务器编程系列1：io_service的工作机制与跨平台策略';
var disqus_url = 'http://powman.org/archives/io-service-detail-1.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//angrypowman.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/archives/cocos2d-x-title.html" class="prev">PREV</a><a href="/archives/asio-server-programming-0.html" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://powman.org">AngryPowman</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-93668618-1",'auto');ga('send','pageview');</script></body></html>