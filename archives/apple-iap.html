<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><title> 苹果IAP安全支付与防范技巧 · 愤怒的泡面</title><meta name="description" content="苹果IAP安全支付与防范技巧 - AngryPowman"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://powman.org/atom.xml" title="愤怒的泡面"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">愤怒的泡面</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/feedback" target="_self" class="li component-nav-item"><p>留言板</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于我</p></a><ul class="shortcut-icons"><a href="https://github.com/AngryPowman" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="https://www.zhihu.com/people/AngryPowman" target="_blank"><img src="/images/zhihu.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">苹果IAP安全支付与防范技巧</h1><div class="post-info">Dec 12, 2014</div><div class="post-content"><p>这两天我在筹备我们的游戏APP的内购，仔细考虑了几个付费安全上的问题。凡是涉及到付费的问题都很敏感，任何一方出现损失都是不能接受的，所以在这里整理一些支付安全的要点分享一下。IAP是指In-App Purchase, 是一种付费方式，而并不是苹果专有的付费方式，在其它平台上也会有不同的实现，这里针对Apple IAP。<br><a id="more"></a><br>说到IAP安全问题，在苹果的IAP流程中有一个比较明显的逻辑漏洞，这个逻辑漏洞是建立在我们处理不当的情况下发生的，会导致己方提供的服务和玩家之间出现问题。先看看IAP支付时序图：<br><a href="/images/wp-migrate-res/2014/12/05C05FF2-C0FB-46C4-9517-D95ED21D595F.jpg"><img src="/images/wp-migrate-res/2014/12/05C05FF2-C0FB-46C4-9517-D95ED21D595F.jpg" alt="sequence_iap"></a></p>
<p>整个支付流程如下：<br>1.客户端向Appstore请求购买产品（假设产品信息已经取得），Appstore验证产品成功后，从用户的Apple账户余额中扣费。<br>2.Appstore向客户端返回一段receipt-data，里面记录了本次交易的证书和签名信息。<br>3.客户端向我们可以信任的游戏服务器提供receipt-data<br>4.游戏服务器对receipt-data进行一次base64编码<br>5.把编码后的receipt-data发往itunes.appstore进行验证<br>6.itunes.appstore返回验证结果给游戏服务器<br>7.游戏服务器对商品购买状态以及商品类型，向客户端发放相应的道具与推送数据更新通知</p>
<p>这七个步骤实际上是一个很安全的流程了。那问题出在哪里呢？我们谈谈两种苹果IAP的验证模型。</p>
<h2 id="IAP-built-in-Model，本地验证"><a href="#IAP-built-in-Model，本地验证" class="headerlink" title="IAP built-in Model，本地验证"></a>IAP built-in Model，本地验证</h2><p>有些单机游戏甚至是网游，都直接跳过了3~7步骤，在第2步拿到receipt-data之后，直接由客户端向itunes.appstore发送验证请求，并且拿到结果，根据结果修改游戏数据。</p>
<p>我们在设计游戏的时候都遵循一个真理，“凡是在客户端的数据都是不安全的”，深以为然。如果没有独立服务器辅助验证，这样也就避免不了数据被修改的事实了，是的，你会少赚钱。不过如果网游也不通过独立服务器验证，而是在客户端验证之后再告知服务器状态让其发放游戏道具，那就太可怕了点。这是IAP built-in Model，经常出现安全问题的逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void paymentQueue(...)</div><div class="line">&#123;</div><div class="line">    if (transaction != nullptr)</div><div class="line">    &#123;</div><div class="line">        me.money += 1000;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码在接收到付费成功的response就直接给游戏发放商品，不对产品和单据进行验证。如果receipt-data允许放在本地验证，就可能发生我们说的免费内购的BUG. 而实际上也真的有类似IAPCracker/IAPFree等工具专门利用这样的IAP漏洞的。而对于已经越狱了的iOS设备就太简单了，甚至不需要通过伪造或者跳过receipt-data验证就可以修改本地数据达到目的。</p>
<p>那是不是就完全不能让这个过程变得安全了呢？也不是，但这个安全保障只是让修改变得困难而已。苹果官方提供了 <a href="https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateLocally.html#//apple_ref/doc/uid/TP40010573-CH1-SW2" target="_blank" rel="external">Validating Receipts Locally</a> 在客户端对receipt-data进行安全验证，主要是对证书以及签名的合法性验证。如果不想自己写代码验证，也可以借助第三方机构提供的receipt-data验证API，比较著名的有 <a href="http://urbanairship.com/products" target="_blank" rel="external">urbanairship</a> 和 <a href="https://www.beeblex.com/public/" target="_blank" rel="external">beeblex</a> 。</p>
<p>但如果能伪造一个完全合法的receipt-data，是不是一样可以达到欺骗目的。是的，为了绕过Validating Locally，于是黑客开始用自己伪造的receipt-data进行移花接木，所以出现了可以伪造”合法订单”的 <a href="http://in-appstore.com/" target="_blank" rel="external">in-appstore</a> 。因此这种本地加强验证的方法也不能完全避免IAP攻击。</p>
<h2 id="IAP-Server-Model，服务器验证"><a href="#IAP-Server-Model，服务器验证" class="headerlink" title="IAP Server Model，服务器验证"></a>IAP Server Model，服务器验证</h2><p>而如果我们把验证逻辑移到服务器上，这个过程就变得容易多了。因为不再需要担心receipt-data被伪造的问题。不过就算把步骤4～7在服务器上做了，同样也会产生一些幼稚的逻辑漏洞：</p>
<p>对验证receipt-data的reponse content不进行验证和记录，只根据Product直接发放商品。这样只要客户端不断提交receipt-data，按照正常逻辑你就需要不断验证并且重复发放商品。较为安全的做法是：</p>
<p><span style="color: #ff0000;">在每一次收到receipt-data之后，都把提交的玩家账号以及receipt-data中的单号建立映射并记录下来，在每次验证receipt-data时，先判断其是否已经存在。</span></p>
<p>只要做了这样的验证，整个支付流程都变得明朗起来。</p>
<h2 id="确保receipt-data的成功提交与异常处理"><a href="#确保receipt-data的成功提交与异常处理" class="headerlink" title="确保receipt-data的成功提交与异常处理"></a>确保receipt-data的成功提交与异常处理</h2><p>建立在IAP Server Model的基础上，并且我们知道手机网络是不稳定的，在付款成功后不能确保把receipt-data一定提交到服务器。如果出现了这样的情况，那就意味着玩家被appstore扣费了，却没收到服务器发放的道具。</p>
<p>解决这个问题的方法是在提交receipt-data的协议上设一个返回值，让服务端告知它已经成功收到并验证了receipt-data. 在没有收到这样的回复之前，客户端必须要把receipt-data保存好，并且定期向服务端发起请求，直至收到服务端的回复为止。</p>
<p>如果是客户端没成功提交receipt-data，那怎么办？就是玩家被扣费了，也收到appstore的消费收据了，却依然没收到游戏道具，于是投诉到游戏客服处。</p>
<p>这种情况在以往的经验中也会出现，常见的玩家和游戏运营商发生的纠纷。游戏客服向玩家索要游戏账号和appstore的收据单号，通过查询itunes-connect看是否确有这笔订单。如果订单存在，则要联系研发方去查询游戏服务器，看订单号与玩家名是否对应，并且是否已经被使用了，做这一点检查的目的是<span style="color: #ff0000;">为了防止恶意玩家利用已经使用过了的订单号进行欺骗</span>，谎称自己没收到商品。这就是上面一节IAP Server Model中红字所提到的安全逻辑的目的。当然了，如果查不到这个订单号，就意味着这个订单确实还没使用过，手动给玩家补发商品即可。</p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'angrypowman';
var disqus_identifier = 'archives/apple-iap.html';
var disqus_title = '苹果IAP安全支付与防范技巧';
var disqus_url = 'http://powman.org/archives/apple-iap.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//angrypowman.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/archives/mathematica-lim.html" class="prev">PREV</a><a href="/archives/item-list-ui.html" class="next">NEXT</a></div><div class="copyright"><p>© 2017 <a href="http://powman.org">AngryPowman</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-93668618-1",'auto');ga('send','pageview');</script></body></html>